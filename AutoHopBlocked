local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local StarterGui = game:GetService("StarterGui")

local TOOL_FOLDER = "datablock"
local REQUEST_FILE = TOOL_FOLDER .. "/_request.txt"
local LOG_FILE = TOOL_FOLDER .. "/_script.log"
local SCRIPT_URL = "https://raw.githubusercontent.com/Nsama239/autohopblocked/main/AutoHopBlocked"
local AUTO_REFRESH_SECONDS = 6 * 60 * 60
local HOP_COOLDOWN = 15
local NOTIFY_SECONDS = 3

local localPlayer = Players.LocalPlayer
local lastHop = 0
local blockedSet = {}
local lastLoadedCount = 0
local requestFunc = (syn and syn.request) or (http and http.request) or request or http_request

local function nowTime()
    local dt = os.date("*t")
    return string.format("%02d:%02d:%02d", dt.hour, dt.min, dt.sec)
end

local function notify(message)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = "Auto Hop Blocked",
            Text = message,
            Duration = NOTIFY_SECONDS,
        })
    end)
end

if _G.AutoHopBlockedRunning then
    notify("Auto Hop Blocked is already running.")
    return
end
_G.AutoHopBlockedRunning = true

local function toHandle(name)
    if not name or name == "" then
        return "@unknown"
    end
    if name:sub(1, 1) == "@" then
        return name
    end
    return "@" .. name
end

local function safeLower(name)
    return string.lower(name or "")
end

local function normalizeName(name)
    local value = name or ""
    value = value:gsub("^%s+", ""):gsub("%s+$", "")
    value = value:gsub("^@", "")
    return safeLower(value)
end

local function canUseTool()
    return isfolder and isfolder(TOOL_FOLDER)
end

local function filePathFor(userName)
    return TOOL_FOLDER .. "/" .. userName .. ".txt"
end

local function sendToolRequest(userName)
    if not writefile then
        return
    end
    pcall(function()
        writefile(REQUEST_FILE, userName .. "|" .. os.time())
    end)
end

local function appendLogLine(line)
    if not writefile then
        return
    end

    pcall(function()
        if appendfile then
            appendfile(LOG_FILE, line .. "\n")
            return
        end

        local current = ""
        if isfile and readfile and isfile(LOG_FILE) then
            current = readfile(LOG_FILE)
        end
        writefile(LOG_FILE, current .. line .. "\n")
    end)
end

local function sendToolLog(message)
    if requestFunc then
        pcall(function()
            requestFunc({
                Url = "http://127.0.0.1:23999/log",
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = HttpService:JSONEncode({ message = message }),
            })
        end)
    end
    appendLogLine(message)
end

local function toolAlive()
    if not requestFunc then
        return false
    end
    local ok, res = pcall(function()
        return requestFunc({ Url = "http://127.0.0.1:23999/ping", Method = "GET" })
    end)
    if not ok or not res or (res.StatusCode ~= 200 and res.StatusCode ~= 204 and res.StatusCode ~= 404) then
        return false
    end
    return true
end

local function isBlockedName(name)
    return blockedSet[normalizeName(name)] == true
end

local function loadBlockedList(userName)
    blockedSet = {}
    if not isfile or not readfile then
        return false
    end

    local path = filePathFor(userName)
    if not isfile(path) then
        local lowerPath = filePathFor(string.lower(userName))
        if isfile(lowerPath) then
            path = lowerPath
        else
            return false
        end
    end

    local data = readfile(path)
    local count = 0
    for line in string.gmatch(data, "[^\r\n]+") do
        local trimmed = string.match(line, "^%s*(.-)%s*$")
        if trimmed and trimmed ~= "" then
            blockedSet[normalizeName(trimmed)] = true
            count += 1
        end
    end

    lastLoadedCount = count
    local msg = string.format("[%s] %s loaded %d blocked users", nowTime(), userName, count)
    appendLogLine(msg)
    sendToolLog(msg)
    return true
end

local function waitForData(userName)
    if not isfolder or not isfolder(TOOL_FOLDER) then
        notify("Turn on the tool first ❌")
        return false
    end

    if not toolAlive() then
        notify("Tool is not running. Start the tool first ❌")
        return false
    end

    if loadBlockedList(userName) then
        return true
    end

    sendToolRequest(userName)
    task.wait(3)

    if loadBlockedList(userName) then
        return true
    end

    notify("Cant read data. Start the tool and try again.")
    return false
end

local function getOtherBlockedSet(otherName)
    if not isfile or not readfile then
        return {}
    end

    local path = filePathFor(otherName)
    if not isfile(path) then
        return {}
    end

    local set = {}
    local data = readfile(path)
    for line in string.gmatch(data, "[^\r\n]+") do
        local trimmed = string.match(line, "^%s*(.-)%s*$")
        if trimmed and trimmed ~= "" then
            set[safeLower(trimmed)] = true
        end
    end
    return set
end

local function chooseStayAccount(conflicts)
    table.sort(conflicts, function(a, b)
        return safeLower(a) < safeLower(b)
    end)
    return conflicts[1]
end

local function fetchServers(cursor)
    local placeId = game.PlaceId
    local url = string.format(
        "https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100%s",
        placeId,
        cursor and ("&cursor=" .. cursor) or ""
    )
    local body = game:HttpGet(url)
    return HttpService:JSONDecode(body)
end

local function findLowServer()
    local cursor = nil
    local bestServer = nil
    local bestPlayers = math.huge

    for _ = 1, 4 do
        local data = fetchServers(cursor)
        for _, server in ipairs(data.data or {}) do
            if server.id ~= game.JobId and server.playing < server.maxPlayers then
                if server.playing < bestPlayers then
                    bestPlayers = server.playing
                    bestServer = server
                end
            end
        end
        cursor = data.nextPageCursor
        if not cursor then
            break
        end
    end

    return bestServer
end

local function hopServer(reasonName)
    if os.time() - lastHop < HOP_COOLDOWN then
        return
    end
    lastHop = os.time()

    local server = findLowServer()
    if server then
        local message = string.format("[%s] %s met %s -> %s switched server (jobId: %s)",
            nowTime(), localPlayer.Name, reasonName, localPlayer.Name, server.id)
        sendToolLog(message)
        notify(string.format("%s met %s -> hopping server", localPlayer.Name, reasonName))
        TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id, localPlayer)
    else
        sendToolLog(string.format("[%s] %s met %s -> no server found", nowTime(), localPlayer.Name, reasonName))
        notify("No server found to hop.")
    end
end

local function scanForConflicts()
    local conflicts = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            local otherName = player.Name
            if isBlockedName(otherName) then
                table.insert(conflicts, otherName)
            else
                local otherBlocked = getOtherBlockedSet(otherName)
                if otherBlocked[normalizeName(localPlayer.Name)] then
                    table.insert(conflicts, otherName)
                end
            end
        end
    end

    if #conflicts == 0 then
        return
    end

    local foundMsg = string.format("[%s] %s found blocked/flagged users: %s", nowTime(), localPlayer.Name, table.concat(conflicts, ", "))
    sendToolLog(foundMsg)
    notify("Found blocked user, hopping...")

    local group = { localPlayer.Name }
    for _, name in ipairs(conflicts) do
        table.insert(group, name)
    end

    local stay = chooseStayAccount(group)
    if safeLower(stay) ~= safeLower(localPlayer.Name) then
        hopServer(conflicts[1])
    end
end

if not canUseTool() then
    notify("Turn on the tool first ❌")
    return
end

if waitForData(localPlayer.Name) then
    notify(string.format("Finally! Success Apply Config to %s, Auto Hop Blocked Enabled ✅", toHandle(localPlayer.Name)))
    sendToolLog(string.format("[%s] %s started Auto Hop Blocked", nowTime(), localPlayer.Name))
    appendLogLine(string.format("[%s] %s started Auto Hop Blocked", nowTime(), localPlayer.Name))

    task.spawn(function()
        while true do
            task.wait(AUTO_REFRESH_SECONDS)
            loadBlockedList(localPlayer.Name)
        end
    end)

    task.spawn(function()
        while true do
            task.wait(3)
            scanForConflicts()
        end
    end)
end
