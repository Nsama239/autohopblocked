
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local StarterGui = game:GetService("StarterGui")

local TOOL_FOLDER = "datablock"
local REQUEST_FILE = TOOL_FOLDER .. "/_request.txt"
local LOG_FILE = TOOL_FOLDER .. "/_script.log"
local HOP_LOG_FILE = TOOL_FOLDER .. "/LogHopBlocked.txt"
local STATUS_FILE = TOOL_FOLDER .. "/AutoHopBlocked.txt"
local AUTO_REFRESH_SECONDS = 6 * 60 * 60
local HOP_COOLDOWN = 15
local NOTIFY_SECONDS = 3

local localPlayer = Players.LocalPlayer
local lastHop = 0
local lastHopAttempt = 0
local blockedSet = {}
local lastLoadedCount = 0
local canMakeFolder = makefolder ~= nil

local function nowTime()
    local dt = os.date("*t")
    return string.format("%02d:%02d:%02d", dt.hour, dt.min, dt.sec)
end

local function notify(message)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = "Auto Hop Blocked",
            Text = message,
            Duration = NOTIFY_SECONDS,
        })
    end)
end

if _G.AutoHopBlockedRunning then
    notify("Auto Hop Blocked is already running.")
    return
end

local function toHandle(name)
    if not name or name == "" then
        return "@unknown"
    end
    if name:sub(1, 1) == "@" then
        return name
    end
    return "@" .. name
end

local function safeLower(name)
    return string.lower(name or "")
end

local function normalizeName(name)
    local value = name or ""
    value = value:gsub("^%s+", ""):gsub("%s+$", "")
    value = value:gsub("^@", "")
    return safeLower(value)
end

local function canUseTool()
    return isfolder and isfolder(TOOL_FOLDER)
end

local function filePathFor(userName)
    return TOOL_FOLDER .. "/" .. userName .. ".txt"
end

local function sendToolRequest(userName)
    if not writefile then
        return
    end
    pcall(function()
        writefile(REQUEST_FILE, userName .. "|" .. os.time())
    end)
end

local function appendLogLine(line, path)
    if not writefile then
        return
    end

    local target = path or LOG_FILE
    pcall(function()
        if appendfile then
            appendfile(target, line .. "\n")
            return
        end

        local current = ""
        if isfile and readfile and isfile(target) then
            current = readfile(target)
        end
        writefile(target, current .. line .. "\n")
    end)
end

local function sendToolLog(message)
    appendLogLine(message, LOG_FILE)
end

local function checkStatusFile()
    if not isfile or not readfile then
        return false
    end
    if not isfile(STATUS_FILE) then
        notify("Please enable Auto Hop Blocked in Settings Tool.")
        return false
    end
    local content = readfile(STATUS_FILE)
    if not content then
        notify("Please enable Auto Hop Blocked in Settings Tool.")
        return false
    end
    local status = string.match(content:lower(), "status%s*=%s*(%w+)")
    if status ~= "on" then
        notify("Please enable Auto Hop Blocked in Settings Tool.")
        return false
    end
    return true
end

local function isBlockedName(name)
    return blockedSet[normalizeName(name)] == true
end

local function loadBlockedList(userName)
    blockedSet = {}
    if not isfile or not readfile then
        return false
    end

    local path = filePathFor(userName)
    if not isfile(path) then
        local lowerPath = filePathFor(string.lower(userName))
        if isfile(lowerPath) then
            path = lowerPath
        else
            return false
        end
    end

    -- Require status flag from tool
    if not checkStatusFile() then
        return false
    end

    local data = readfile(path)
    local count = 0
    for line in string.gmatch(data, "[^\r\n]+") do
        local trimmed = string.match(line, "^%s*(.-)%s*$")
        if trimmed and trimmed ~= "" then
            blockedSet[normalizeName(trimmed)] = true
            count += 1
        end
    end

    lastLoadedCount = count
    local msg = string.format("[%s] %s loaded %d blocked users", nowTime(), userName, count)
    appendLogLine(msg)
    sendToolLog(msg)
    return true
end

local function waitForData(userName)
    if not isfolder then
        notify("Executor missing isfolder function; cannot read tool data.")
        return false
    end

    if not isfolder(TOOL_FOLDER) then
        if canMakeFolder then
            pcall(makefolder, TOOL_FOLDER)
        end
        if not isfolder(TOOL_FOLDER) then
            notify("Tool data folder missing (datablock).")
            return false
        end
    end

    -- First try existing data file.
    if loadBlockedList(userName) then
        return true
    end

    -- Ask tool once (if possible), then retry.
    sendToolRequest(userName)
    task.wait(2)

    if loadBlockedList(userName) then
        return true
    end

    notify("Cannot read blocked data. Ensure tool is on and data is available.")
    return false
end

local function getOtherBlockedSet(otherName)
    if not isfile or not readfile then
        return {}
    end

    local path = filePathFor(otherName)
    if not isfile(path) then
        return {}
    end

    local set = {}
    local data = readfile(path)
    for line in string.gmatch(data, "[^\r\n]+") do
        local trimmed = string.match(line, "^%s*(.-)%s*$")
        if trimmed and trimmed ~= "" then
            set[safeLower(trimmed)] = true
        end
    end
    return set
end

local function chooseStayAccount(conflicts)
    table.sort(conflicts, function(a, b)
        return safeLower(a) < safeLower(b)
    end)
    return conflicts[1]
end

local function fetchServers(cursor)
    local placeId = game.PlaceId
    local url = string.format(
        "https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100%s",
        placeId,
        cursor and ("&cursor=" .. cursor) or ""
    )
    local ok, body = pcall(function()
        return game:HttpGet(url)
    end)
    if not ok or type(body) ~= "string" then
        return nil
    end
    local okDecode, decoded = pcall(function()
        return HttpService:JSONDecode(body)
    end)
    if not okDecode then
        return nil
    end
    return decoded
end

local function findLowServer()
    local cursor = nil
    local bestServer = nil
    local bestPlayers = math.huge

    for _ = 1, 4 do
        local data = fetchServers(cursor)
        if not data then
            break
        end
        for _, server in ipairs(data.data or {}) do
            if server.id ~= game.JobId and server.playing < server.maxPlayers then
                local playing = tonumber(server.playing) or math.huge
                if playing < bestPlayers then
                    bestPlayers = playing
                    bestServer = server
                end
            end
        end
        cursor = data.nextPageCursor
        if not cursor then
            break
        end
    end

    return bestServer
end

local function hopServer(reasonName)
    if os.time() - lastHop < HOP_COOLDOWN then
        return
    end
    lastHop = os.time()

    -- Log to hop log file for the cmd reader (always log before attempting to hop)
    appendLogLine(string.format("[%s] %s met %s -> preparing to hop", nowTime(), localPlayer.Name, reasonName), HOP_LOG_FILE)

    local server = findLowServer()
    if server then
        local message = string.format("[%s] %s met %s -> %s switched server (jobId: %s)",
            nowTime(), localPlayer.Name, reasonName, localPlayer.Name, server.id)
        sendToolLog(message)
        appendLogLine(string.format("[%s] Requesting teleport to job %s", nowTime(), server.id), HOP_LOG_FILE)
        notify(string.format("%s met %s -> hopping server", localPlayer.Name, reasonName))
        local ok, err = pcall(function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id, localPlayer)
        end)
        if not ok then
            appendLogLine(string.format("[%s] TeleportToPlaceInstance failed: %s", nowTime(), tostring(err)), HOP_LOG_FILE)
            notify("Teleport failed, will retry when cooldown ends.")
        end
    else
        -- Fallback: attempt Teleport to place (let Roblox choose server) but only once per cooldown window
        if os.time() - lastHopAttempt >= HOP_COOLDOWN then
            lastHopAttempt = os.time()
            appendLogLine(string.format("[%s] No server found -> fallback Teleport to place", nowTime()), HOP_LOG_FILE)
            local ok, err = pcall(function()
                TeleportService:Teleport(game.PlaceId)
            end)
            if not ok then
                appendLogLine(string.format("[%s] Fallback Teleport failed: %s", nowTime(), tostring(err)), HOP_LOG_FILE)
            end
        end
        sendToolLog(string.format("[%s] %s met %s -> no server found", nowTime(), localPlayer.Name, reasonName))
        notify("No server found to hop.")
    end
end

local function scanForConflicts()
    local conflicts = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            local otherName = player.Name
            if isBlockedName(otherName) then
                table.insert(conflicts, otherName)
            else
                local otherBlocked = getOtherBlockedSet(otherName)
                if otherBlocked[normalizeName(localPlayer.Name)] then
                    table.insert(conflicts, otherName)
                end
            end
        end
    end

    if #conflicts == 0 then
        return
    end

    -- Respect hop cooldown to avoid spam and ensure we actually attempt a hop.
    if os.time() - lastHop < HOP_COOLDOWN then
        return
    end

    local foundMsg = string.format("[%s] %s found blocked/flagged users: %s", nowTime(), localPlayer.Name, table.concat(conflicts, ", "))
    sendToolLog(foundMsg)
    notify("Found blocked user, hopping...")

    appendLogLine(string.format("[%s] Found blocked user(s): %s -> attempting hop", nowTime(), table.concat(conflicts, ", ")), HOP_LOG_FILE)
    hopServer(conflicts[1])
end

if not canUseTool() then
    notify("Tool data folder missing (datablock).")
    return
end

if waitForData(localPlayer.Name) then
    _G.AutoHopBlockedRunning = true
    notify(string.format("Finally! Success Apply Config to %s, Auto Hop Blocked Enabled âœ…", toHandle(localPlayer.Name)))
    sendToolLog(string.format("[%s] %s started Auto Hop Blocked", nowTime(), localPlayer.Name))
    appendLogLine(string.format("[%s] %s started Auto Hop Blocked", nowTime(), localPlayer.Name))

    task.spawn(function()
        while true do
            task.wait(AUTO_REFRESH_SECONDS)
            loadBlockedList(localPlayer.Name)
        end
    end)

    task.spawn(function()
        while true do
            task.wait(3)
            scanForConflicts()
        end
    end)
end
